From ac22f596c864972294addfabad3683df4f775334 Mon Sep 17 00:00:00 2001
From: Geo Min <geomin12@amd.com>
Date: Wed, 27 Aug 2025 15:53:13 -0700
Subject: [PATCH 05/25] [TheRock CI] Run all TheRock CI jobs if `therock*`
 files are updated (#1306)

Previously, we would have to test via workflow_dispatch for TheRock CI
changes.

This PR now makes any TheRock CI changes to test TheRock CI
---
 .../tests/therock_configure_ci_test.py        |  8 ++
 .github/scripts/therock_configure_ci.py       | 91 ++++++++++++++++---
 .github/workflows/therock-ci.yml              | 15 +--
 3 files changed, 87 insertions(+), 27 deletions(-)

diff --git a/.github/scripts/tests/therock_configure_ci_test.py b/.github/scripts/tests/therock_configure_ci_test.py
index 7933a10579..60ca070021 100644
--- a/.github/scripts/tests/therock_configure_ci_test.py
+++ b/.github/scripts/tests/therock_configure_ci_test.py
@@ -68,6 +68,14 @@ class ConfigureCITest(unittest.TestCase):
         
         project_to_run = therock_configure_ci.retrieve_projects(args)
         self.assertGreaterEqual(len(project_to_run), 1)
+        
+    def test_is_path_workflow_file_related_to_ci(self):
+        workflow_path = ".github/workflows/therocktest.yml"
+        self.assertTrue(therock_configure_ci.is_path_workflow_file_related_to_ci(workflow_path))
+        script_path = ".github/scripts/therocktest.py"
+        self.assertTrue(therock_configure_ci.is_path_workflow_file_related_to_ci(script_path))
+        bad_path = ".github/workflows/test.yml"
+        self.assertFalse(therock_configure_ci.is_path_workflow_file_related_to_ci(bad_path))
 
 if __name__ == "__main__":
     unittest.main()
diff --git a/.github/scripts/therock_configure_ci.py b/.github/scripts/therock_configure_ci.py
index 9547b2e7d2..851c91a54c 100644
--- a/.github/scripts/therock_configure_ci.py
+++ b/.github/scripts/therock_configure_ci.py
@@ -5,14 +5,19 @@ Required environment variables:
   - SUBTREES
 """
 
+import fnmatch
 import json
 import logging
+import subprocess
+import sys
 from therock_matrix import subtree_to_project_map, project_map
-from typing import Mapping
+import time
+from typing import Mapping, Optional, Iterable
 import os
 
 logging.basicConfig(level=logging.INFO)
 
+
 def set_github_output(d: Mapping[str, str]):
     """Sets GITHUB_OUTPUT values.
     See https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/passing-information-between-jobs
@@ -20,39 +25,97 @@ def set_github_output(d: Mapping[str, str]):
     logging.info(f"Setting github output:\n{d}")
     step_output_file = os.environ.get("GITHUB_OUTPUT", "")
     if not step_output_file:
-        logging.warning("Warning: GITHUB_OUTPUT env var not set, can't set github outputs")
+        logging.warning(
+            "Warning: GITHUB_OUTPUT env var not set, can't set github outputs"
+        )
         return
     with open(step_output_file, "a") as f:
         f.writelines(f"{k}={v}" + "\n" for k, v in d.items())
         
-        
+def retry(max_attempts, delay_seconds, exceptions):
+    def decorator(func):
+        def newfn(*args, **kwargs):
+            attempt = 0
+            while attempt < max_attempts:
+                try:
+                    return func(*args, **kwargs)
+                except exceptions as e:
+                    print(f'Exception {str(e)} thrown when attempting to run , attempt {attempt} of {max_attempts}')
+                    attempt += 1
+                    if attempt < max_attempts:
+                        backoff = delay_seconds * (2 ** (attempt - 1))
+                        time.sleep(backoff)
+            return func(*args, **kwargs)
+        return newfn
+    return decorator
+
+@retry(max_attempts=3, delay_seconds=2, exceptions=(TimeoutError))
+def get_modified_paths(base_ref: str) -> Optional[Iterable[str]]:
+    """Returns the paths of modified files relative to the base reference."""
+    return subprocess.run(
+        ["git", "diff", "--name-only", base_ref],
+        stdout=subprocess.PIPE,
+        check=True,
+        text=True,
+        timeout=60,
+    ).stdout.splitlines()
+
+
+GITHUB_WORKFLOWS_CI_PATTERNS = [
+    "therock*",
+]
+
+
+def is_path_workflow_file_related_to_ci(path: str) -> bool:
+    return any(
+        fnmatch.fnmatch(path, ".github/workflows/" + pattern)
+        for pattern in GITHUB_WORKFLOWS_CI_PATTERNS
+    ) or any(
+        fnmatch.fnmatch(path, ".github/scripts/" + pattern)
+        for pattern in GITHUB_WORKFLOWS_CI_PATTERNS
+    )
+
+
+def check_for_workflow_file_related_to_ci(paths: Optional[Iterable[str]]) -> bool:
+    if paths is None:
+        return False
+    return any(is_path_workflow_file_related_to_ci(p) for p in paths)
+
+
 def retrieve_projects(args):
     if args.get("is_pull_request"):
         subtrees = args.get("input_subtrees").split("\n")
-    
+
     if args.get("is_workflow_dispatch"):
         if args.get("input_projects") == "all":
             subtrees = list(subtree_to_project_map.keys())
         else:
             subtrees = args.get("input_projects").split()
-    
+
     # If a push event to develop happens, we run tests on all subtrees
     if args.get("is_push"):
         subtrees = list(subtree_to_project_map.keys())
-    
+
+    # If .github/*/therock* were changed, run all subtrees
+    base_ref = args.get("base_ref")
+    modified_paths = get_modified_paths(base_ref)
+    print("modified_paths (max 200):", modified_paths[:200])
+    related_to_therock_ci = check_for_workflow_file_related_to_ci(modified_paths)
+    if related_to_therock_ci:
+        subtrees = list(subtree_to_project_map.keys())
+
     projects = set()
     # collect the associated subtree to project
     for subtree in subtrees:
         if subtree in subtree_to_project_map:
             projects.add(subtree_to_project_map.get(subtree))
-            
-    
-    # retrieve the subtrees to checkout, cmake options to build, and projects to test 
+
+    # retrieve the subtrees to checkout, cmake options to build, and projects to test
     project_to_run = []
     for project in projects:
         if project in project_map:
             project_to_run.append(project_map.get(project))
-        
+
     return project_to_run
 
 
@@ -67,13 +130,15 @@ if __name__ == "__main__":
     args["is_pull_request"] = github_event_name == "pull_request"
     args["is_push"] = github_event_name == "push"
     args["is_workflow_dispatch"] = github_event_name == "workflow_dispatch"
-    
+
     input_subtrees = os.getenv("SUBTREES", "")
     args["input_subtrees"] = input_subtrees
-    
+
     input_projects = os.getenv("PROJECTS", "")
     args["input_projects"] = input_projects
-    
+
+    args["base_ref"] = os.environ.get("BASE_REF", "HEAD^")
+
     logging.info(f"Retrieved arguments {args}")
 
     run(args)
diff --git a/.github/workflows/therock-ci.yml b/.github/workflows/therock-ci.yml
index 7e23bc8c48..19e667d94d 100644
--- a/.github/workflows/therock-ci.yml
+++ b/.github/workflows/therock-ci.yml
@@ -39,14 +39,7 @@ jobs:
         with:
           sparse-checkout: .github
           sparse-checkout-cone-mode: true
-
-      # # will be needed for `patch_monorepo.py` but necessary now
-      # - name: Checkout TheRock Repository
-      #   uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
-      #   with:
-      #     repository: "ROCm/TheRock"
-      #     path: "TheRock"
-      #     ref: 0730cccf8b98e012d64750f26032bd760360fa45
+          fetch-depth: 2
 
       - name: Set up Python
         uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
@@ -58,12 +51,6 @@ jobs:
           python -m pip install --upgrade pip
           pip install pydantic requests
 
-    # # For our "rocPRIM" MVP, there are no patches to apply. This will be un-commented and used later!
-    #   - name: Patch monorepo
-    #     run: |
-    #       python TheRock/build_tools/github_actions/patch_monorepo.py \
-    #         --repo rocm-libraries
-
       - name: Detect changed subtrees
         id: detect
         if: github.event_name == 'pull_request'
-- 
2.47.1.windows.2

